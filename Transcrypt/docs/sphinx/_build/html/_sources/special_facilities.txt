Special facilities
==================

Transcrypt's module mechanism
-----------------------------

Transcrypt's module mechanism looks a lot like Python's but there are a few differences.
Firstly it is good practice to use url-based unique module identifiers, e.g.

- *com.github.<my name>.<my module name>*
- *org.python.pypi.<my module name>*
- *com.<myc company name>.<my module name>*

To achieve optimal CPython compatibility, an exeption is made for modules that are part of the CPython distribution, e.g.

- *itertools*
	
Note that Transcrypt is meant be to used with JavaScript rather than Python libraries, to keep it lightweight. For computations e.g. JavaScripts *Math* object, rather then Python's *math* module is currently used. Nevertheless porting (part of) some standard libraries might be handy. If you do, you're invited to make them available via PyPi, using 'Transcrypt' in your keyword list.

Finding the code for a module proceeds as follows:

Suppose you import a module *all.the.kings.men*. Then the following paths will be searched respectively:

- *<directory of your main module>/all/the/kings/men.py*
- *<directory of your main module>/all/the/kings/__javascript__/men.mod.js*
- *<directory of your main module>/all/the/kings/men/__init__py*
- *<directory of your main module>/all/the/kings/men/__javascript__/__init__.mod.js*

- *transcrypt/Transcrypt/modules/all/the/kings/men.py*
- *transcrypt/Transcrypt/modules/all/the/kings/__javascript__/men.mod.js*
- *transcrypt/Transcrypt/modules/all/the/kings/men/__init__py*
- *transcrypt/Transcrypt/modules/all/the/kings/men/__javascript__/__init__.mod.js*

As can be seen from the above list, modules local to your project take precedence of globally available modules. If both a Python and a JavaScript module are present, the Python module is only recompiled if it's younger than the corresponding JavaScript module, unless the -b switch is used.

Furthermore, note that the *__init__.py* or *__init__.mod.js* file of a module is executed if and only if that module is imported, not if it's just somewhere in the hierarchy of directories containing that module. Furthermore the global code of a module is executed only once, no matter how often that module is imported, as is equally the case with CPython.

As a consequence of the above, modules may be distributed as Python *.py* files, but also as JavaScript-only *.mod.js* files. The JavaScript files may be hand written or generated by any tool including Transcrypt. Although they may be distributed in minified form, don't give them the extension *.mod.min.js*, that exension is reserved for minification by Transcrypt itself. Since Trancrypt will minify your files anyhow, you're encouraged to distribute the original, human readable sources, to facilitate debugging by users of your library.

Using browser stubs to test non-GUI code that uses console.log, window.alert and  sort
--------------------------------------------------------------------------------------
To test the non-GUI part of your code in a desktop rather than a browser environment, use *from org.transcrypt.stubs.browser import \**. This will allow you to call the *window.alert*, *console.log* and *sort* functions in your code when you run it from the command prompt, using the -r command line switch: *transcrypt -r <my main file name>*. This will invoke CPython, searching the appropriate module paths as compilation would have done.

The *sort* global function has the same in-place sorting functionality as the Python *sort* method. When using *sort* as a method rather than a global function in a Transcrypt source file, the JavaScript *sort* is used. The functionality of this method differs slightly from its Python counterpart. To allow seamless integration with existing JavaScript libaries, both functions are available: the JavaScript one as a method and the Python one as a global function.

Keeping your code lean: __pragma__ ('kwargs') and __pragma__ ('nokwargs')
-------------------------------------------------------------------------
While it's possible to compile with the -k switch, allowing keyword arguments in all flavors supported by Python 3.5 in all places, this disadvised, as it leads to bloated code. It is better to use the 'kwargs' and 'nokwargs' pragmas, to enable this feature only at definition (as opposed to calling) of functions that require it. You'll find an example of how to use these pragma's in the :ref:`arguments autotest <autotest_arguments>`. You can use them on whole modules or any part thereof. Note that at due to the dynamic nature of Python, use of keyword arguments at call time cannot be predicted at definition time. When running with CPython from the command prompt using the browser stubs, these pragma's are ignored.

Inserting literal JavaScript: __pragma__ ('js', code, <format parameters>) and include (<relative module path>)
---------------------------------------------------------------------------------------------------------------
During compilation the 'js' pragma is replaced by the JavaScript code given in the *code* parameter. This code is formatted using the Python *str.format* method, using *<format parameters>*.

An example of its use is to encapsulate a JavaScript library as a Python module, as is :ref:`shown  for the fabric.js library <code_encaps_fabric>`. In that case there's usually one format parameter, namely a call to *include (<relative module path>)*. The module path is either relative to the directory holding the main module of your project, or to the root of the modules directory, and searched in that order. So modules local to your project prevail over generally available modules.

.. _pragma_alias:

Identifier aliasing: __pragma__ ('alias', <Python identifier or fragment>, <JavaScript identifier or fragment>)
---------------------------------------------------------------------------------------------------------------
Using this pragma at the start of a module will replace identifiers or fragments thereof like in the following examples:

Example 1:

+--------------------------------------------------------------------+
| Used at the start of the module: *__pragma__ ('alias', 'S', $)*    |
+-----------------------------------------+--------------------------+
| Original in Python:                     | Alias in JavaScript:     |
+-----------------------------------------+--------------------------+
| *S ('body')*                            | *$ ('body')*             |
+-----------------------------------------+--------------------------+
| *S_body*                                | *$body*                  |
+-----------------------------------------+--------------------------+
| *S_She_S_Sells_S_Sea_S_Shells_S*        | *$She$Sells$Sea$Shells$* |
+-----------------------------------------+--------------------------+

Example 2:

+--------------------------------------------------------------------+
| Used at the start of the module *__pragma__ ('alias', 'jq', '$')*  |
+-----------------------------------------+--------------------------+
| *jq_body = jq (body)*                   | *$body = $ ('body')*     |
+-----------------------------------------+--------------------------+

Note that the generated JavaScript only the modified identifiers will be present, not the original ones. So the JavaScript identifiers are only aliases for the Python ones, not for any identifier in the JavaScript code itself.

Identifier filtering
--------------------
Ordinary Python identifiers may have a special meaning in JavaScript. In compilation they are replaced by 'innocent' ones like in the following example:

+---------------------+-------------------------+
| Original in Python: | Filtered in JavaScript: |
+---------------------+-------------------------+
| *arguments*         | *__$arguments__*        |
+---------------------+-------------------------+

Creating JavaScript objects with __new__ (<constructor call>)
-------------------------------------------------------------

While creating objects in Transcrypt mostly happens in the plain Python way, e.g. *canvas = Canvas (<parameters>)*, objects from 3rd party JavaScript libraries often have to be created using *new*. In Transcrypt such objects are created by calling the  *__new__* function, e.g. *canvas = __new__ (Canvas (<parameters>)*, as can be seen in the :ref:`Pong example<code_pong>`. This mechanism is simple, follows Python's syntax rules and doesn't require updating of an encapsulation layer if a later version of the underlying JavaScript library features additional constructor functions. Therefore in most cases it is the preferred way to create objects who's initialization requires calling 3rd party JavaScript constructor functions.

As an alternative, instantiation and construction can be encapsulated in one function call. Since this in fact creates an alternative API facade for the 3rd party JavaScript library, such an encapsulation should be kept separate from the original library, e.g. by putting it in a separate importable module. The JavaScript code for this encapsulation would e.g. be *<facade module name>.Canvas = function (<parameters>) {return new Canvas (<parameters>);};*. After importing the facade module, canvas creation is straightforward: *canvas = Canvas (<parameters>)*.

As a third alternative, encapsulation can be done in Python rather than JavaScript: *def Canvas (<parameters>): return __new__ (<3rd party module name>.Canvas (<parameters>)*. Also in this case the creation syntax is simple: *canvas = Canvas (<parameters>)*.

